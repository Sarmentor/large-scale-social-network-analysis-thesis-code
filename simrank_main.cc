/*###############################################################################
#							Similarity Ranking Algorithm 						#
#								Jeh and Widom (2002)							#
#																				#
#					Implementation version with Green-Marl Language				#
#					by Rui Sarmento												#
#					for "Large Scale Social Network Analysis"					#
#					Master Thesis - 2013										#
#																				#
################################################################################*/
#include "simrank.h"         // header generated by gm_comp
#include <sys/time.h>
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <stdlib.h>
#include <unistd.h>

#define WONT_OPEN 20

#include <sys/types.h>
#include <dirent.h>
using namespace std;

//todo - convert to hash_map as desired.
typedef map<long, string> NodeMap;
typedef map<string, long> NameMap;

void add_node(gm_graph *G, NameMap *names, NodeMap *nodes, long id, string name) {
  G->add_node(); 
  (*names)[name] = id;
  (*nodes)[id] = name;
}

//void load_edge_list(gm_graph *G, NameMap *names, NodeMap *nodes, char filename[256], char separator, char directed[256]) {
void load_edge_list(gm_graph *G, NameMap *names, NodeMap *nodes, string filename, char separator, string directed) { 
  ifstream file;
  file.open(filename, fstream::in );
  cout << "\nOpened File " << filename;
  if (!(file.is_open())) {
	cout << "\nFile is not open... ";
    throw WONT_OPEN;  
  }
  
  cout << "\nInitializing Variables... ";
  if(directed.compare("n")==0){
  cout << "\nGraph is undirected!";
  } else if(directed.compare("y")==0){
  cout << "\nGraph is directed!";
  }
  string line;
  long int node_counter = 0;
  long int edge_counter = 0;
  cout << "\nBegining While Loop to read the edge list file... ";
  while(file.good()) {  
	getline(file, line);
    if (line.find('#') != std::string::npos) continue;
    if(file.eof()) break;
    size_t split = line.find(separator);
    string u = line.substr(0, split);
    string v = line.substr(split+1);
	if(names->count(u) == 0) {
      add_node(G, names, nodes, node_counter++, u);
    } 
    if(names->count(v) == 0) {
      add_node(G, names, nodes, node_counter++, v);
    }
	if (directed.compare("n")==0){//graph is undirected
	G->add_edge((*names)[u], (*names)[v]);
	G->add_edge((*names)[v], (*names)[u]);
	edge_counter++;
	} else if(directed.compare("y")==0){//graph is directed
	G->add_edge((*names)[u], (*names)[v]);
	edge_counter++;
	}
  }
  cout << "\nGraph has "<< node_counter << " Nodes!";
  cout << "\nGraph has "<< edge_counter << " Edges!";
  cout << "\nIMPORTANT NOTE: With this Graph, memory use will be approximately around " << 2*node_counter*node_counter*4/1000000 << "MB MAX";
  cout << "\nPLEASE MAKE SURE YOUR MACHINE'S MEMORY IS ENOUGH TO RUN THE ALGORITHM!!";
  cout << "\nClosing Edge List file...";
  file.close();
  cout << "\nClosed Edge List file!";
}

//function to translate internal green-marl nodes Ids to edge list nodes
void compile_results(NameMap *names, NodeMap *nodes) {
  //for reading raw results file
  ifstream file;
  //for writing final results file
  ofstream resultsfile;
  resultsfile.open("results-simrank.txt",fstream::in | fstream::out | fstream::app);
  
  //for writing final results file
  //resultsfile=fopen("results-communities.txt","a");
  
  //for reading raw results file
long size;
char *buf;
char *ptr;
size = pathconf(".", _PC_PATH_MAX);
if ((buf = (char *)malloc((size_t)size)) != NULL)
    ptr = getcwd(buf, (size_t)size);
	//cout << string(buf).append("/results-simrank-raw.txt");
  file.open(string(buf).append("/results-simrank-raw.txt"), fstream::in );
  //file.open("/home/110414015/Green-Marl/apps/output_cpp/bin/results-simrank-raw.txt", fstream::in | fstream::out | fstream::app);
  cout << "\nOpening Raw Results File ";
  if (!(file.is_open())) {
	cout << "\nFile is not open... ";
    throw WONT_OPEN;  
  }
  string line;
  long int node_counter = 0;
  long int edge_counter = 0;
  long int line_counter = 0;
  cout << "\nBegining While Loop to read the Raw file... ";
  while(file.good()) {
	//cout << "\nRead Lines started..." ;
    //line = (char) file.get();
	getline(file, line);
	line_counter++;
	//std::stringstream(line);
	//cout << "\nRead Line: " << line;
    if (line.find('#') != std::string::npos) continue;
    if(file.eof()) break;
	if (line_counter==1){
	size_t split = line.find('\t');
	string v = line.substr(split+1);
	size_t split2 = v.find('\t');
	string node1 = v.substr(0, split2);
	v = v.substr(split2+1);
	//cout << "\nNode1: " << node1;
	string s_u = (*names).find((*nodes).find(stol(node1))->second)->first;
	resultsfile << '\t' << s_u.c_str() ;
	do{
	if (v.find('\t')==std::string::npos){
	//cout << "\nNo tab and End of line " << v;
	break;
	} else if (v.find('\t')!=std::string::npos)
	{
	split = v.find('\t');
	string node = v.substr(0, split);
	//cout << "\nTab and Node: "<< node;
	v = v.substr(split+1);
	s_u = (*names).find((*nodes).find(stol(node))->second)->first;
	resultsfile << '\t' << s_u.c_str();
	}	
	}while(true);
	//for writing final results file
	if (resultsfile !=NULL){
	resultsfile << "\r\n";
	} else 
	{
	printf("Unable to open file results-simrank.txt to write results");
	throw WONT_OPEN;
	} 
	} else {
	size_t split = line.find('\t');
	string node1 = line.substr(0, split);
	//cout << "\n New Line: " << line;
	//cout << "\nNode: " << node1;
	string s_u = (*names).find((*nodes).find(stol(node1))->second)->first;
	resultsfile << s_u.c_str() ;
	string v = line.substr(split+1);
	do{
	if (v.find('\t')==std::string::npos){
	//cout << "\n New Line: " << line;
	//cout << "\nNode: " << v;
	resultsfile << '\t' << v;
	break;
	} else if (v.find('\t')!=std::string::npos)
	{
	split = v.find('\t');
	string value = v.substr(0, split);
	v = v.substr(split+1);
	resultsfile << '\t' << value;
	}	
	}while(true);
	//for writing final results file
	if (resultsfile !=NULL){
	resultsfile << "\r\n";
	} else 
	{
	printf("Unable to open file results-simrank.txt to write results");
	throw WONT_OPEN;
	}
	}
}
//fclose(resultsfile);
resultsfile.close();
}


int main(int argc, char** argv){
gm_graph G;
NameMap names;
NodeMap nodes;
string directed;
string file_name;
time_t timer, timer_end;
struct tm * ptm_start;
struct tm * ptm_end;
float ptm_interval; 

 puts("\n################################");
 puts("#####  SimRank Algorithm   #####");
 puts("################################\n");

if( remove( "results-simrank-raw.txt" ) != 0 )
    puts( "No need for 1st cleaning task...continuing..." );
  else
    puts( "1st Cleaning Task Successfully Done" );
if( remove( "results-simrank.txt" ) != 0 )
    puts( "No need for 2nd cleaning task...continuing..." );
  else
    puts( "2nd Cleaning Task Successfully Done" );

printf("Is the graph directed? Answer y (yes) or n (no): ");
cin >> directed;
printf("Input graph file name (only unweighted edge list is accepted!!): ");
cin >> file_name;
time(&timer);  /* get current time; same as: timer = time(NULL)  */
ptm_start = gmtime(&timer);
cout << "Started Computation of Similarity Ranking (Simrank): " << ptm_start->tm_hour << ":" << ptm_start->tm_min << "\n";
cout << "Loading Edge List...";
load_edge_list(&G, &names, &nodes, file_name, '\t', directed);
cout << "\nCalculating Simrank for every node...";
cout.flush();
simrank(G);
time(&timer_end);  /* get current time; same as: timer_end = time(NULL)  */
ptm_end = gmtime(&timer_end);
cout << "\nEnded Computation of Simrank at: " << ptm_end->tm_hour << ":" << ptm_end->tm_min << "\n";
ptm_interval = difftime(timer_end,timer);
cout << "Processing Time - " << ptm_interval/3600 << " hours, " << ptm_interval/60  << " minutes OR "<< ptm_interval <<" seconds \n";
cout << "Compiling Results...";
compile_results(&names, &nodes);
cout << "\nFile results-simrank.txt has the algorithm results! Enjoy!\n";

 puts("\n################################");
 puts("#####  SimRank Algorithm   #####");
 puts("################################\n");

return 0;
} 

 